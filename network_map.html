<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TBC Networks Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Favicon -->
  <link rel="icon" href="/assets/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <style>
    :root { --label-size: 12px; }
    html, body { height: 100%; margin: 0; }
    #map { height: calc(100% - 60px); }

    /* ===== Header/Nav ===== */
    header { background-color: #bf3426; color: #fff; }
    .nav { height: 60px; display: flex; align-items: center; gap: 16px; padding: 0 16px; max-width: 1100px; margin: 0 auto; }
    .nav .brand { display: flex; align-items: center; gap: 10px; text-decoration: none; color: #fff; font-weight: 800; letter-spacing: 0.3px; }
    .nav .brand img { height: 36px; width: auto; display: block; }
    .nav-links { display: flex; align-items: center; gap: 18px; margin-left: auto; }
    .nav-links a { color: #fff; text-decoration: none; font-weight: 700; padding: 6px 4px; border-radius: 4px; opacity: 0.9; }
    .nav-links a:hover { text-decoration: underline; opacity: 1; }
    .nav-links a.active { text-decoration: underline; opacity: 1; }
    .nav, .nav a, .nav .brand { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif !important; }

    /* Title */
    .map-title {
      position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
      z-index: 1000;
      font: 40px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 800; color: #111; text-align: center;
      background: rgba(255,255,255,0.9);
      padding: 14px 25px; border-radius: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      pointer-events: none;
    }

    .leaflet-interactive { cursor: pointer; }

    /* ================= Legend ================= */
    .legend-panel {
      position: absolute;
      top: 70px; left: 10px;
      width: 300px; max-height: calc(100% - 90px);
      overflow-y: auto;
      z-index: 1000;
      background: rgba(255,255,255,0.95);
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.12);
      padding: 10px;
      font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }
    /* Desktop hide/show support */
    .legend-panel.closed { display: none; }

    .legend-header { display: none; }
    /* Flush-right total badge */
    .legend-title {
      font-weight: 700; font-size: 14px; margin: 4px 0 8px; color: #111;
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
      width: 100%;
    }
    .legend-title .county-count { margin-left: 8px; }

    /* Darker styling for Networks by County */
    #countySection.filter-block {
      background: #e2e8f0; /* slightly darker shade */
      border-color: #cbd5e1;
    }
    #countySection .filter-summary { background: #e5e7eb; }
    #countySection[open] .filter-summary { background: #dbeafe; }

    .county-group { margin-bottom: 6px; border-radius: 8px; }
    .county-group summary {
      list-style: none; cursor: pointer;
      padding: 8px 10px; border-radius: 8px;
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
      background: #f8fafc; border: 1px solid #e5e7eb; position: sticky; top: 0;
    }
    .county-name { font-weight: 600; color: #111; }
    .county-count { font-size: 12px; color: #374151; background: #e5e7eb; border-radius: 999px; padding: 2px 8px; }
    .county-group[open] summary { background: #eef2ff; }

    .legend-list { list-style: none; padding: 6px 0 0; margin: 0; position: relative; }
    .legend-item { display: flex; align-items: center; gap: 10px; padding: 6px 8px; border-radius: 8px; cursor: pointer; }
    .legend-item:hover { background: #f3f4f6; }
    .swatch { width: 16px; height: 16px; border-radius: 4px; border: 1px solid rgba(0,0,0,.15); flex: 0 0 16px; box-shadow: inset 0 0 0 1px rgba(255,255,255,.25); }
    .legend-name { color: #111; }

    .legend-popup {
      position: absolute; left: 8px; right: 8px; z-index: 5;
      background: #fff; color: #111; border: 1px solid #e5e7eb;
      border-radius: 10px; box-shadow: 0 4px 14px rgba(0,0,0,.12);
      padding: 10px 12px 12px;
    }
    .legend-popup .close { display: none; } /* removed close button */

    /* Show the toggle button on ALL viewports */
    .legend-toggle {
      display: inline-flex; align-items: center; justify-content: center;
      position: fixed; left: 12px; bottom: 12px; z-index: 1001;
      background: #111; color: #fff; border: 0;
      border-radius: 999px; padding: 10px 14px; font: 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.2);
    }
    .legend-toggle:active { transform: translateY(1px); }

    /* -------- Mobile (<768px) -------- */
    @media (max-width: 767.98px) {
      .map-title { font-size: 22px; padding: 10px 16px; border-radius: 14px; }
      .legend-panel {
        position: fixed; top: 0; bottom: 0; left: 0; right: auto;
        width: 50vw; max-width: none; height: 100vh;
        border-radius: 0 12px 12px 0; padding: 8px 10px 12px;
        transform: translateX(-100%); transition: transform 220ms ease;
        border-left: 0; border-right: 1px solid #e5e7eb;
        box-shadow: 0 4px 16px rgba(0,0,0,.12);
        background: rgba(255,255,255,0.98);
        -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y;
      }
      .legend-panel.open { transform: translateX(0); }

      .legend-header {
        display: flex; align-items: center; justify-content: space-between;
        gap: 8px; padding: 6px 2px 8px; position: sticky; top: 0;
        background: rgba(255,255,255,0.98); z-index: 2;
      }
      .legend-grabber { width: 40px; height: 4px; border-radius: 2px; background: #cbd5e1; margin: 4px auto 8px auto; }
      .legend-title { margin: 0 0 8px; }

      .desktop-only { display: none; }

      /* Hide Leaflet +/- zoom on mobile */
      .leaflet-control-zoom { display: none !important; }
    }

    /* Shared popup content */
    .tip { font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .tip .label { color:#666; }
    .tip-name { font-size: 15px; font-weight: 600; margin-bottom: 2px; color: #111; }

    /* WRAPPED polygon labels */
    .poly-label{
      background: transparent; border: 0; box-shadow: none;
      color: #1f2937;
      font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      text-align: center;
      /* wrap only at spaces/normal breakpoints */
      white-space: normal;
      overflow-wrap: break-word;   /* NOT 'anywhere' */
      word-break: keep-all;        /* don't break inside words */
      max-width: 200px;            /* a bit wider so names fit */
      line-height: 1.15;
      text-shadow: 0 1px 2px rgba(255,255,255,.85), 0 0 2px rgba(255,255,255,.9);
      pointer-events: none;
      font-size: var(--label-size, 12px);
      /* (optional) nicer multi-line balancing in modern browsers */
      text-wrap: balance;
    }


    .leaflet-tooltip.hover-tip {
      background: #fff; color: #111;
      border: 1px solid #e5e7eb; border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,.12);
      padding: 8px 10px;
    }
    .leaflet-tooltip.hover-tip:before { display: none; }

    .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-top: 8px; }
    .gallery a { display:block; border-radius:8px; overflow:hidden; box-shadow: 0 1px 4px rgba(0,0,0,.12); }
    .gallery img { display:block; width:100%; height:100%; object-fit: cover; aspect-ratio: 4 / 3; }
    hr { border:0; border-top:1px solid #e9ecef; margin:8px 0; }

    .leaflet-control-layers .basemap-heading,
    .leaflet-control-layers .overlays-heading { font-weight: 600; margin-bottom: 4px; display: block; }

    /* ===== Mobile info sheet (modal) ===== */
    .sheet{ position: fixed; inset:0; z-index:1002; display:none; }
    .sheet.open{ display:block; }
    .sheet-backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.35); }
    .sheet-panel{ position:absolute; left:0; right:0; bottom:0; background:#fff; border-radius:16px 16px 0 0; box-shadow: 0 -6px 24px rgba(0,0,0,.25); max-height:85vh; overflow:auto; padding:16px; }
    .sheet-close{ position:absolute; top:8px; right:8px; border:0; background:#f3f4f6; border-radius:999px; width:32px; height:32px; font-size:18px; }
    .sheet .tip{ font-size:14px; }
    .sheet .tip-name{ font-size:18px; margin-bottom:4px; }
    .sheet .actions{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .sheet .actions a{ color:#0a58ca; text-decoration:underline; font-weight:700; }
    @media (min-width: 768px){ .sheet{ display:none !important; } } /* only show on mobile */
    .leaflet-popup-content a, .leaflet-popup-content button{ pointer-events:auto; }
  
/* === Tag Chips (popup + filters) === */
.chips { display:flex; flex-wrap:wrap; gap:6px; margin:6px 0 2px; }
.chip {
  display:inline-flex; align-items:center; gap:6px;
  padding:4px 8px; border-radius:999px; font-size:12px; font-weight:600;
  color:#111; border:1px solid rgba(0,0,0,.12); background:#f3f4f6;
}
.chip.dark { color:#fff; border-color: rgba(0,0,0,.25); }
.chip .dot { width:10px; height:10px; border-radius:999px; box-shadow: inset 0 0 0 1px rgba(0,0,0,.15); }

/* === Filters section (Status + Unify Lead) === */
.filter-section { border:1px solid #e5e7eb; border-radius:10px; padding:8px; background:#f9fafb; margin-bottom:10px; }
.filter-section h4 { margin:4px 0 8px; font-size:13px; font-weight:700; }
.filter-group { margin:6px 0 8px; }
.filter-group .label { font-size:12px; font-weight:700; color:#374151; margin-bottom:4px; }
.chip-select { display:flex; flex-wrap:wrap; gap:6px; }
.chip-option { position:relative; display:inline-block; }
.chip-option input { position:absolute; opacity:0; pointer-events:none; }
.chip-option label { cursor:pointer; }
.chip-option input:checked + label { outline:2px solid #111; outline-offset:1px; }

.filter-actions { display:flex; gap:8px; margin-top:6px; }
.filter-actions button {
  background:#111; color:#fff; border:0; border-radius:8px; padding:6px 10px; font-size:13px; font-weight:700;
}
.filter-actions .clear { background:#6b7280; }


/* Collapsible filter blocks */
.filters-heading { font-size: 18px; font-weight: 800; margin: 6px 2px 10px; }
.filter-block { border:1px solid #e5e7eb; border-radius:10px; background:#f9fafb; margin:8px 0; }
.filter-summary {
  list-style: none; cursor: pointer; padding: 10px 12px; border-radius: 10px;
  display:flex; align-items:center; justify-content: space-between; gap:8px;
  background:#f8fafc; border-bottom:1px solid #e5e7eb; font-weight:700; color:#111;
}
.filter-block[open] .filter-summary { background:#eef2ff; }
.filter-block .filter-group { padding: 8px 10px 10px; }
.map-and-chips { display:flex; align-items:center; flex-wrap:wrap; gap:8px; margin-top:4px; }
.chips-inline .chips { display:inline-flex; margin:0; }
.legend-list { list-style:none; }

</style>
</head>
<body>
  <div id="navbar-include"></div>
  <script src="include-nav.js"></script>

  <div id="map">
    <div hidden class="map-title">TBC Networks</div>

    <!-- Toggle button on all viewports -->
    <button id="legendToggle" class="legend-toggle" type="button" aria-expanded="false" aria-controls="legendPanel">
      Filter
    </button>

    
<aside class="legend-panel" id="legendPanel" aria-label="Filters panel">
  <div class="legend-header">
    <div class="legend-grabber" aria-hidden="true"></div>
    <div class="legend-title">Filters</div>
  </div>

<!-- County Section first -->
<details id="countySection" class="filter-block">
<summary class="filter-summary">
Network by County <span id="totalNetworksDesktop" class="county-count">0</span>
</summary>
<div id="legendGroups"></div>
</details>


<!-- Filters UI below -->
<section class="filter-section" id="filtersUI" aria-label="Filter controls">
<h3 class="filters-heading">Filter Networks</h3>


<details class="filter-block" id="statusSection">
<summary class="filter-summary">Status</summary>
<div class="filter-group">
<div id="statusChips" class="chip-select"></div>
</div>
</details>


<details class="filter-block" id="leadSection">
<summary class="filter-summary">Unify Lead</summary>
<div class="filter-group">
<div id="leadChips" class="chip-select"></div>
</div>
</details>


<div class="filter-actions">
<button id="applyFilters" type="button">Apply</button>
<button id="clearFilters" class="clear" type="button">Clear</button>
</div>
</section>
</aside>


  </div>

  <!-- Mobile info sheet (modal) -->
  <div id="infoSheet" class="sheet" aria-hidden="true">
    <div class="sheet-backdrop" data-close="1"></div>
    <div class="sheet-panel" role="dialog" aria-modal="true" aria-labelledby="sheetTitle">
      <button class="sheet-close" type="button" data-close="1" aria-label="Close">×</button>
      <div id="sheetContent"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // Detect domain and set configuration
    const isMapsSubdomain = window.location.hostname === 'maps.tbc.city';
    
    // Map with custom zoom control placement (avoid legend overlap)
    const map = L.map('map', { center: [37.8, -122.3], zoom: 9, preferCanvas: true, zoomControl: false });
    L.control.zoom({ position: 'bottomright' }).addTo(map);

    // ---- Custom panes for strict z-order ----
    map.createPane('countiesPane');  // background polygons
    map.getPane('countiesPane').style.zIndex = 200;

    map.createPane('networksPane');  // main polygons
    map.getPane('networksPane').style.zIndex = 400;

    map.createPane('labelsPane');    // permanent polygon labels
    map.getPane('labelsPane').style.zIndex = 450;
    map.getPane('labelsPane').style.pointerEvents = 'none'; // labels never block clicks

    map.createPane('hoverPane');     // transient hover tooltips
    map.getPane('hoverPane').style.zIndex = 460;
    map.getPane('hoverPane').style.pointerEvents = 'none';

    map.createPane('popupsPane');    // click popups / info windows
    map.getPane('popupsPane').style.zIndex = 700;

    // Basemaps
    const esriGray = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' }).addTo(map);
    const cartoPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 20, subdomains: 'abcd', attribution: '&copy; OpenStreetMap contributors &copy; CARTO' });
    const esriWorldStreet = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' });
    const esriTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' });
    const baseMaps = { 'Light': esriGray, 'Medium': cartoPositron, 'Street': esriWorldStreet, 'Topo': esriTopo };

    // Overlays
    const networksGroup = L.layerGroup().addTo(map);
    const countiesGroup = L.layerGroup().addTo(map);

    const layerControl = L.control.layers(baseMaps, { 'Networks': networksGroup, 'Counties': countiesGroup }, { position: 'topright', collapsed: false }).addTo(map);
    const controlEl = layerControl.getContainer();
    const baseList = controlEl.querySelector('.leaflet-control-layers-base');
    if (baseList) { const h = document.createElement('div'); h.className = 'basemap-heading'; h.textContent = 'Basemap'; baseList.prepend(h); }
    const overlayList = controlEl.querySelector('.leaflet-control-layers-overlays');
    if (overlayList) { const h = document.createElement('div'); h.className = 'overlays-heading'; h.textContent = 'Layers'; overlayList.prepend(h); }

    // Helpers
    const palette30 = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf','#393b79','#637939','#8c6d31','#843c39','#7b4173','#3182bd','#31a354','#756bb1','#636363','#e6550d','#9edae5','#c7c7c7','#bc80bd','#ffed6f','#a6cee3','#b2df8a','#fb9a99','#fdbf6f','#cab2d6','#6a3d9a'];
    function hashIndex(str, m) { let h = 0; for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i))|0; return Math.abs(h)%m; }
    function colorForFeature(ft) { const p = ft.properties || {}; const key = String(p.id || p.name || JSON.stringify(ft.geometry) || Math.random()); return palette30[hashIndex(key, palette30.length)]; }
    function styleNetworks(ft) { return { color: '#333', weight: 1.5, fillColor: colorForFeature(ft), fillOpacity: 0.5 }; }

    // === Chip utilities ===
    function luminance(hex) {
      try {
        const c = hex.replace('#','');
        const r = parseInt(c.substring(0,2),16)/255;
        const g = parseInt(c.substring(2,4),16)/255;
        const b = parseInt(c.substring(4,6),16)/255;
        // relative luminance
        const a = [r,g,b].map(v => (v <= 0.03928) ? v/12.92 : Math.pow((v+0.055)/1.055, 2.4));
        return 0.2126*a[0] + 0.7152*a[1] + 0.0722*a[2];
      } catch { return 0.5; }
    }
    function chipHtml(label, withDot=true){
      const color = palette30[hashIndex(String(label), palette30.length)];
      const dark = luminance(color) < 0.45;
      const dot = withDot ? '<span class="dot" data-legacy-dot="1" hidden style="background:'+color+'"></span>' : '';
      return '<span class="chip'+(dark?' dark':'')+'" style="background:'+color+';">'+dot+escapeHtml(label)+'</span>';
    }
    function chipsHtml(labels){
      if (!labels || !labels.length) return '';
      return '<div class="chips">'+labels.map(chipHtml).join('')+'</div>';
    }
    function chipsHtmlNoDots(labels){
      if (!labels || !labels.length) return '';
      return labels.map(l=>chipHtml(l,false)).join('');
    }
    function toArray(v){
      if (!v) return [];
      if (Array.isArray(v)) return v.filter(Boolean).map(String);
      return String(v).split(/[,;|/]/).map(s=>s.trim()).filter(Boolean);
    }
    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch])); }

    // === Filter state ===
    const selectedStatus = new Set();
    const selectedLeads  = new Set();
    let allLegendItems = []; // {county, name, color, props, layer}
    let allStatusValues = new Set();
    let allLeadValues   = new Set();

    function matchesFilters(props){
      const statusVals = toArray(props.status);
      const leadVals   = toArray(props.unify_lead);
      const statusOK = (selectedStatus.size === 0) || statusVals.some(v => selectedStatus.has(v));
      const leadOK   = (selectedLeads.size  === 0) || leadVals.some(v => selectedLeads.has(v));
      return statusOK && leadOK;
    }

    function buildFilterChips(){
      const statusEl = document.getElementById('statusChips');
      const leadEl   = document.getElementById('leadChips');
      function build(el, values, set){
        el.innerHTML = '';
        Array.from(values).sort((a,b)=>a.localeCompare(b,undefined,{sensitivity:'base'})).forEach(val => {
          const id = 'f_'+btoa(unescape(encodeURIComponent(''+val))).replace(/=/g,'')+Math.floor(Math.random()*1e6);
          const color = palette30[hashIndex(String(val), palette30.length)];
          const dark = luminance(color) < 0.45;
          const checked = set.has(val) ? ' checked' : '';
          el.insertAdjacentHTML('beforeend',
            '<span class="chip-option">'
            + '<input type="checkbox" id="'+id+'" value="'+escapeHtml(val)+'"'+checked+' />'
            + '<label class="chip'+(dark?' dark':'')+'" for="'+id+'" style="background:'+color+';">'+escapeHtml(val)+'</label>'
            + '</span>'
          );
        });
      }
      build(statusEl, allStatusValues, selectedStatus);
      build(leadEl,   allLeadValues,   selectedLeads);

      // Wire up change handlers
      statusEl.querySelectorAll('input[type="checkbox"]').forEach(input => {
        input.addEventListener('change', () => {
          if (input.checked) selectedStatus.add(input.value); else selectedStatus.delete(input.value);
        });
      });
      leadEl.querySelectorAll('input[type="checkbox"]').forEach(input => {
        input.addEventListener('change', () => {
          if (input.checked) selectedLeads.add(input.value); else selectedLeads.delete(input.value);
        });
      });
    }

    function applyFilters(){
      // 1) Show/hide polygons and their labels
      networksGeoJson.eachLayer((layer) => {
        const props = layer.feature && layer.feature.properties || {};
        const vis = matchesFilters(props);
        layer.setStyle({ fillOpacity: vis ? 0.5 : 0.0, opacity: vis ? 1.0 : 0.0 });
        layer._path && (layer._path.style.pointerEvents = vis ? 'auto' : 'none');
        
        // Hide/show the tooltip (label) based on filter
        if (layer.getTooltip()) {
          layer.getTooltip().setOpacity(vis ? 1 : 0);
        }
      });
      // 2) Rebuild legend list
      const filteredItems = allLegendItems.filter(it => matchesFilters(it.props));
      const groups = new Map();
      filteredItems.forEach(it => {
        if (!groups.has(it.county)) groups.set(it.county, []);
        groups.get(it.county).push(it);
      });
      buildCountyLegend(groups);
    }

    function clearFilters(){
      selectedStatus.clear();
      selectedLeads.clear();
      buildFilterChips();
      applyFilters();
    }

    // Hook up buttons after DOM ready
    document.addEventListener('DOMContentLoaded', () => {
      // Hide filter sections and related elements on maps subdomain
      if (isMapsSubdomain) {
        const statusSection = document.getElementById('statusSection');
        const leadSection = document.getElementById('leadSection');
        const filtersUI = document.getElementById('filtersUI');
        if (statusSection) statusSection.style.display = 'none';
        if (leadSection) leadSection.style.display = 'none';
        if (filtersUI) filtersUI.style.display = 'none';
      }
      
      const applyBtn = document.getElementById('applyFilters');
      const clearBtn = document.getElementById('clearFilters');
      if (applyBtn) applyBtn.addEventListener('click', () => { applyFilters(); try{ document.getElementById('countySection').open = true; }catch{} });
      if (clearBtn) clearBtn.addEventListener('click', () => { clearFilters(); });
    });

    function highlight(e){ e.target.setStyle({ weight: 3, color:'#000', fillOpacity: 0.7 }); }
    function resetHighlight(e){ networksGeoJson && networksGeoJson.resetStyle(e.target); }
    function cleanedName(name){ if (!name || typeof name !== 'string') return 'Unnamed'; return name.replace(/\bnetworks?\b/gi,'').replace(/\s+/g,' ').trim() || 'Unnamed'; }
    function multilineName(name){ return cleanedName(name).split(/\s+/).filter(Boolean).join('<br>'); }
    function allPhotos(props = []){ return [props.photo1,props.photo2,props.photo3,props.photo4,props.photo5,props.photo6].filter(u => typeof u === 'string' && u.trim()); }
    function renderGallery(photos){ if (!photos.length) return ''; const items = photos.map((p,i)=>'<a href="'+p+'" target="_blank" rel="noopener"><img src="'+p+'" alt="Photo '+(i+1)+'" loading="lazy" /></a>').join(''); return '<hr/><div class="gallery">'+items+'</div>'; }
    
    // === Conditional link rendering based on church count ===
    function getChurchCount(props={}){
      const raw = props['number of churches'] ?? props.number_of_churches ?? props.numberOfChurches ?? props.church_count ?? props.churches ?? 0;
      const n = Number(raw);
      return Number.isFinite(n) && n > 0 ? n : 0;
    }

    function churchesLine(rawName, statusArr = [], leadArr = [], props={}){
      const count = getChurchCount(props);
      const showLink = count > 0;

      if (isMapsSubdomain) {
        return showLink
          ? '<div class="map-and-chips"><a href="/org_map?network='+encodeURIComponent(rawName)+'" target="_blank" rel="noopener">Map of Network Churches</a></div>'
          : '';
      }
      
      const statusChips = statusArr.length ? chipsHtmlNoDots(statusArr) : '';
      const leadChips = leadArr.length ? chipsHtmlNoDots(leadArr) : '';
      const allChips = [statusChips, leadChips].filter(Boolean).join(' ');

      const linkHtml = showLink
        ? '<a href="/org_map?network='+encodeURIComponent(rawName)+'" target="_blank" rel="noopener">Map of Network Churches</a>'
        : '';

      if (!linkHtml && allChips){
        return '<div class="map-and-chips"><span class="chips-inline">'+allChips+'</span></div>';
      }

      return '<div class="map-and-chips">'+linkHtml
        + (allChips ? ' <span class="chips-inline">'+allChips+'</span>' : '')
        + '</div>';
    }

    // NEW: Prayer Request line
    function prayerLine(v){
      const s = (v == null ? '' : String(v)).trim();
      return s ? '<div><span class="label">Prayer Request:</span> ' + escapeHtml(s) + '</div>' : '';
    }

    function infoCardHtml(props = {}){
      const rawName = (props.name && String(props.name).trim()) || 'Unnamed';
      const emailLine = props.contact_email ? '<div><span class="label">Email:</span> <a href="mailto:'+props.contact_email+'">'+props.contact_email+'</a></div>' : '';
      const statusArr = toArray(props.status);
      const leadArr   = toArray(props.unify_lead);
      const photos = allPhotos(props);
      return '<div class="tip">'
        + '<div class="tip-name">'+rawName+'</div>'
        + '<div><span class="label">Leaders:</span> '+(props.leaders ?? '—')+'</div>'
        + emailLine
        + prayerLine(props.latest_prayer_request)          // added
        + churchesLine(rawName, statusArr, leadArr, props)
        + renderGallery(photos)
        + '</div>';
    }


    // Legend state & helpers
    const legendPanel = document.getElementById('legendPanel');
    const legendGroupsEl = document.getElementById('legendGroups');
    const legendToggle = document.getElementById('legendToggle');
    const totalDesktopEl = document.getElementById('totalNetworksDesktop');
    const totalMobileEl = document.getElementById('totalNetworksMobile');
    let legendPopupEl = null;
    let legendPopupAnchorEl = null;

    // ===== Mobile Info Sheet helpers =====
    const sheetEl = document.getElementById('infoSheet');
    const sheetContentEl = document.getElementById('sheetContent');

    function openSheet(content) {
      if (sheetContentEl) sheetContentEl.innerHTML = content;
      if (sheetEl) {
        sheetEl.classList.add('open');
        sheetEl.setAttribute('aria-hidden', 'false');
        lockScroll();
      }
    }

    function closeSheet() {
      if (sheetEl) {
        sheetEl.classList.remove('open');
        sheetEl.setAttribute('aria-hidden', 'true');
        unlockScroll();
      }
    }

    document.addEventListener('click', (e) => {
      if (e.target.closest('[data-close="1"]')) {
        closeSheet();
      }
    });

    function infoSheetHtml(props = {}){
      const rawName = (props.name && String(props.name).trim()) || 'Unnamed';
      const emailLine = props.contact_email ? '<div><span class="label">Email:</span> <a href="mailto:'+props.contact_email+'">'+props.contact_email+'</a></div>' : '';
      const statusArr = toArray(props.status);
      const leadArr   = toArray(props.unify_lead);
      const photos = allPhotos(props);
      return '<div class="tip">'
        + '<div class="tip-name" id="sheetTitle">'+rawName+'</div>'
        + '<div><span class="label">Leaders:</span> '+(props.leaders ?? '—')+'</div>'
        + emailLine
        + prayerLine(props.latest_prayer_request)          // added
        + churchesLine(rawName, statusArr, leadArr, props)
        + renderGallery(photos)
        + '</div>';
    }

    function isMobile() { return window.matchMedia('(max-width: 767.98px)').matches; }
    function isTouch() { return window.matchMedia('(pointer: coarse)').matches; }

    L.DomEvent.disableScrollPropagation(legendPanel);
    L.DomEvent.disableClickPropagation(legendPanel);

    let scrollLockY = 0;
    function lockScroll() { scrollLockY = window.scrollY || document.documentElement.scrollTop || 0; document.body.style.position='fixed'; document.body.style.top=`-${scrollLockY}px`; document.body.style.left='0'; document.body.style.right='0'; document.body.style.width='100%'; document.body.style.overflow='hidden'; document.documentElement.style.overflow='hidden'; }
    function unlockScroll() { document.body.style.position=''; document.body.style.top=''; document.body.style.left=''; document.body.style.right=''; document.body.style.width=''; document.body.style.overflow=''; document.documentElement.style.overflow=''; window.scrollTo(0, scrollLockY); }

    function openLegend() {
      if (isMobile()) { legendPanel.classList.add('open'); lockScroll(); }
      legendPanel.classList.remove('closed');
      if (legendToggle) legendToggle.setAttribute('aria-expanded', 'true');
    }
    function closeLegend() {
      if (isMobile()) { legendPanel.classList.remove('open'); unlockScroll(); }
      legendPanel.classList.add('closed');
      if (legendToggle) legendToggle.setAttribute('aria-expanded', 'false');
    }
    if (legendToggle) legendToggle.addEventListener('click', () => {
      const isHiddenDesktop = legendPanel.classList.contains('closed');
      const isOpenMobile = legendPanel.classList.contains('open');
      (isMobile() ? !isOpenMobile : isHiddenDesktop) ? openLegend() : closeLegend();
    });

    function repositionLegendPopup() {
      if (!legendPopupEl || !legendPopupAnchorEl) return;
      const panelRect = legendPanel.getBoundingClientRect();
      const aRect = legendPopupAnchorEl.getBoundingClientRect();
      const relativeTop = (aRect.top - panelRect.top) + legendPanel.scrollTop + legendPopupAnchorEl.offsetHeight + 6;
      legendPopupEl.style.top = relativeTop + 'px';
    }
    legendPanel.addEventListener('scroll', repositionLegendPopup);
    window.addEventListener('resize', repositionLegendPopup);

    function showLegendPopup(anchorEl, html) {
      if (legendPopupEl) legendPopupEl.remove();
      const el = document.createElement('div');
      el.className = 'legend-popup';
      el.innerHTML = html;
      legendPanel.appendChild(el);

      const panelRect = legendPanel.getBoundingClientRect();
      const aRect = anchorEl.getBoundingClientRect();
      const relativeTop = (aRect.top - panelRect.top) + legendPanel.scrollTop + anchorEl.offsetHeight + 6;
      el.style.top = relativeTop + 'px';

      legendPopupEl = el;
      legendPopupAnchorEl = anchorEl;
      if (isMobile()) openLegend();
    }

    // ========== Robust random-open infrastructure ==========
    let networksGeoJson;                 // will hold the GeoJSON layer
    const networksReadyQueue = [];       // callbacks to run after networks are ready
    let randomOpened = false;            // guard to prevent double-opening

    function onNetworksReady(cb){
      if (networksGeoJson) cb();
      else networksReadyQueue.push(cb);
    }

    function hasRandomParam(){
      const params = new URLSearchParams(location.search);
      return params.has('random');
    }

    function openRandomNetworkOnce(){
      if (randomOpened) return;
      if (!networksGeoJson) return;
      const allLayers = [];
      networksGeoJson.eachLayer(l => allLayers.push(l));
      console.log('[Random] layers:', allLayers.length);
      if (!allLayers.length) return;

      randomOpened = true;

      const pick = allLayers[Math.floor(Math.random() * allLayers.length)];
      const bounds = pick.getBounds && pick.getBounds();
      const props = (pick.feature && pick.feature.properties) || {};
      console.log('[Random] picked:', props && props.name);

      if (bounds && bounds.isValid && bounds.isValid()) {
        let opened = false;
        const openPopupNow = () => {
          if (opened) return;
          opened = true;
          if (isMobile()) {
            openSheet(infoSheetHtml(props));
          } else {
            pick.bindPopup(infoCardHtml(props), { maxWidth: 480, closeOnClick: false, autoClose: true, pane: 'popupsPane' });
            pick.openPopup(bounds.getCenter());
            if (pick.bringToFront) pick.bringToFront();
          }
        };

        map.fitBounds(bounds.pad(0.15), { animate: true });
        map.once('moveend', openPopupNow);
        // Fallback in case moveend doesn't fire for any reason
        setTimeout(openPopupNow, 800);
      }
    }
    // =======================================================

    // Load Networks
    fetch('https://api.tbc.city/networks/polygons.geojson', { cache: 'no-cache' })
      .then(res => res.json())
      .then(data => {
        const groups = new Map();

        networksGeoJson = L.geoJSON(data, {
          pane: 'networksPane',
          style: styleNetworks,
          onEachFeature: (feature, layer) => {
            // Labels over polygons use cleaned, WRAPPED name
            layer.bindTooltip(cleanedName(feature.properties?.name), { permanent: true, direction: 'center', className: 'poly-label', opacity: 1, pane: 'labelsPane' });
            layer.on('mouseover', (e) => { if (isTouch()) return; 
              highlight(e);
              const tip = L.tooltip({ className: 'hover-tip', direction: 'top', opacity: 0.95, offset: [0,-8], pane: 'hoverPane' })
                .setContent(infoCardHtml(feature.properties))
                .setLatLng(e.latlng);
              layer._hoverTip = tip; tip.addTo(map);
            });
            layer.on('mousemove', (e) => { if (isTouch()) return;  if (layer._hoverTip) layer._hoverTip.setLatLng(e.latlng); });
            layer.on('mouseout', (e) => { if (isTouch()) return; 
              resetHighlight(e);
              if (layer._hoverTip) { map.removeLayer(layer._hoverTip); layer._hoverTip = null; }
            });
            layer.on('click', () => {
              const props = feature.properties || {};
              if (isMobile()) {
                openSheet(infoSheetHtml(props));
              } else {
                layer.bindPopup(infoCardHtml(props), { maxWidth: 480, closeOnClick: false, autoClose: true, pane: 'popupsPane' }).openPopup();
              }
            });

            const props = feature.properties || {};
            const county = (props.County && String(props.County).trim()) || (props.county && String(props.county).trim()) || 'Unspecified';
            const nameClean = cleanedName(props.name || 'Unnamed');
            const item = { county, name: nameClean, color: colorForFeature(feature), props, layer };
            allLegendItems.push(item);

            toArray(props.status).forEach(v => allStatusValues.add(v));
            toArray(props.unify_lead).forEach(v => allLeadValues.add(v));
          }
        }).addTo(networksGroup);

        const b = networksGeoJson.getBounds();
        if (b.isValid()) map.fitBounds(b.pad(0.05));

        buildFilterChips();
        applyFilters();
        updateLabelSizes();

        // flush queued callbacks
        while (networksReadyQueue.length) {
          try { networksReadyQueue.shift()(); } catch(e) { console.error(e); }
        }
      })
      .catch(err => console.error('Failed to load polygons.geojson:', err));

    function buildCountyLegend(groups) {
      const counties = Array.from(groups.keys()).sort((a, b) => {
        if (a === 'Unspecified' && b !== 'Unspecified') return 1;
        if (b === 'Unspecified' && a !== 'Unspecified') return -1;
        return a.localeCompare(b, undefined, { sensitivity: 'base' });
      });

      // Total networks count
      let total = 0;
      groups.forEach(arr => { total += arr.length; });
      if (totalDesktopEl) totalDesktopEl.textContent = total;
      if (totalMobileEl) totalMobileEl.textContent = total;

      const legendGroupsEl = document.getElementById('legendGroups');
      legendGroupsEl.innerHTML = '';
      counties.forEach((county) => {
        const items = groups.get(county).slice().sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
        const details = document.createElement('details');
        details.className = 'county-group';

        const summary = document.createElement('summary');
        const nameEl = document.createElement('span'); nameEl.className = 'county-name'; nameEl.textContent = county;
        const countEl = document.createElement('span'); countEl.className = 'county-count'; countEl.textContent = items.length;
        summary.appendChild(nameEl); summary.appendChild(countEl);

        const ul = document.createElement('ul'); ul.className = 'legend-list';

        items.forEach((item) => {
          const li = document.createElement('li'); li.className = 'legend-item';
          const swatch = document.createElement('span'); swatch.className = 'swatch'; swatch.style.background = item.color;
          const label = document.createElement('span'); label.className = 'legend-name'; label.innerHTML = item.name;
          li.appendChild(swatch); li.appendChild(label); ul.appendChild(li);

          li.addEventListener('click', (e) => {
            e.stopPropagation();
            try {
              if (legendPopupEl) { legendPopupEl.remove(); legendPopupEl = null; legendPopupAnchorEl = null; }
              const b = item.layer.getBounds();
              if (b && b.isValid && b.isValid()) {
                map.fitBounds(b.pad(0.15), { animate: true });
                item.layer.setStyle({ weight: 3, color: '#000', fillOpacity: 0.7 });
                setTimeout(() => { networksGeoJson && networksGeoJson.resetStyle(item.layer); }, 1200);
                if (isMobile()) {
                  openSheet(infoSheetHtml(item.props));
                } else {
                  const center = b.getCenter();
                  item.layer.bindPopup(infoCardHtml(item.props), { maxWidth: 480, closeOnClick: false, autoClose: true, pane: 'popupsPane' });
                  item.layer.openPopup(center);
                  if (item.layer.bringToFront) item.layer.bringToFront();
                }
              }
            } catch (err) {
              console.error('Legend click action failed:', err);
              const html = infoSheetHtml(item.props);
              openSheet(html);
            }
          });
        });

        details.appendChild(summary);
        details.appendChild(ul);
        legendGroupsEl.appendChild(details);
        details.addEventListener('toggle', () => setTimeout(repositionLegendPopup, 0));
      });
    }

    // Counties layer
    function styleCounties(){ return { color:'#b59f3b', weight:1, fillColor:'#fff9c4', fillOpacity:0.5 }; }
    fetch('tbc_counties.geojson', { cache: 'no-cache' })
      .then(res => res.json())
      .then(data => {
        const counties = L.geoJSON(data, { pane: 'countiesPane', style: styleCounties }).addTo(countiesGroup);
        const b = counties.getBounds();
        if (b.isValid()) {
          const current = map.getBounds();
          const union = current.isValid() ? current.extend(b) : b;
        }
      });

    // ===== Label responsiveness to zoom (mobile & desktop) =====
    function updateLabelSizes() {
      const z = map.getZoom();
      const mobile = isMobile();
      const base = mobile ? 10 : 10.5;
      const slope = mobile ? 1.0 : 1.1;
      let size = base + (z - 8) * slope;
      const min = mobile ? 9 : 10;
      const max = 22;
      if (size < min) size = min;
      if (size > max) size = max;
      document.documentElement.style.setProperty('--label-size', size.toFixed(1) + 'px');
    }
    map.on('zoomend', updateLabelSizes);
    map.whenReady(updateLabelSizes);

    // ===== Kick off random-open if requested =====
    if (hasRandomParam()) {
      console.log('[Random] param detected');
      onNetworksReady(openRandomNetworkOnce);
      // extra defense in case networks load *very* quickly or late
      setTimeout(() => onNetworksReady(openRandomNetworkOnce), 100);
      setTimeout(() => onNetworksReady(openRandomNetworkOnce), 600);
    }

    window.addEventListener('resize', updateLabelSizes);

    map.on('popupopen', (e) => {
      const el = e.popup && e.popup.getElement && e.popup.getElement();
      if (!el) return;
      try { L.DomEvent.disableClickPropagation(el); L.DomEvent.disableScrollPropagation(el); } catch {}
    });
  </script>
</body>
</html>
