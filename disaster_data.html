<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TBC Disaster Data Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f6f7fb;
    }
    #map {
      position: absolute; inset: 0; width: 100%; height: 100vh; z-index: 1;
    }
    .filter-panel {
      position: absolute; top: 12px; left: 12px;
      width: min(360px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      background: #fff; border-radius: 14px; box-shadow: 0 6px 22px rgba(0,0,0,0.15);
      overflow: hidden; display: flex; flex-direction: column; z-index: 1000;
    }
    .panel-header { padding: 12px 14px; border-bottom: 1px solid #e8e8ee; background: #fff; }
    .panel-header h2 { font-size: 16px; font-weight: 600; margin: 0; }
    .panel-scroll {
      overflow-y: auto; -webkit-overflow-scrolling: touch;
      padding: 10px 12px 14px;
      max-height: calc(100vh - 24px - 56px);
    }
    details { border: 1px solid #ececf3; border-radius: 12px; background: #fafbff; margin-bottom: 10px; padding: 6px 8px; }
    details[open] { background: #f5f7ff; }
    summary { list-style: none; cursor: pointer; font-weight: 600; font-size: 14px; }
    summary::-webkit-details-marker { display: none; }
    .summary-row { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    .chev { transition: transform .2s ease; }
    details[open] .chev { transform: rotate(90deg); }
    .group-help { color: #555; font-size: 12px; margin: 6px 2px 8px; }
    .tag-list { display: grid; grid-template-columns: 1fr; gap: 6px; margin-top: 8px; }
    .tag-pill { display: inline-flex; align-items: center; gap: 8px; border: 1px solid #e3e6ef; border-radius: 999px; padding: 6px 10px; background: #fff; font-size: 13px; cursor: pointer; user-select: none; }
    .tag-pill input { cursor: pointer; }
    .panel-actions { display: flex; gap: 8px; padding: 10px 12px 12px; border-top: 1px solid #ececf3; background: #fff; }
    .btn { border: 1px solid #d9deea; background: #fff; padding: 8px 12px; border-radius: 10px; font-size: 13px; cursor: pointer; }
    .btn-primary { border-color: #3b82f6; background: #3b82f6; color: #fff; }
    .popup { font-size: 13px; line-height: 1.35; min-width: 240px; max-width: 340px; }
    .popup h3 { font-size: 15px; margin: 0 0 6px; }
    .field-row { margin: 4px 0; }
    .field-row b { font-weight: 600; }
    .tag-strip { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 4px; }
    .chip { display: inline-block; padding: 3px 8px; border-radius: 999px; border: 1px solid #e1e5ee; background: #f8fafc; font-size: 12px; }
    @media (max-width: 640px) { .filter-panel { width: calc(100vw - 24px); } }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Legend/filter panel -->
  <aside class="filter-panel" id="filterPanel">
    <div class="panel-header"><h2>Legend & Filters</h2></div>
    <div class="panel-scroll" id="panelScroll">
      <details id="grp-regular" open>
        <summary><div class="summary-row"><span>Regular Services</span><span class="chev">▶</span></div></summary>
        <div class="group-help">Select one or more to filter. If none are selected, this group is ignored.</div>
        <div class="tag-list" id="list-regular"></div>
      </details>
      <details id="grp-disaster" open>
        <summary><div class="summary-row"><span>Disaster Services</span><span class="chev">▶</span></div></summary>
        <div class="group-help">Select one or more to filter. If none are selected, this group is ignored.</div>
        <div class="tag-list" id="list-disaster"></div>
      </details>
      <details id="grp-physical" open>
        <summary><div class="summary-row"><span>Physical Resources</span><span class="chev">▶</span></div></summary>
        <div class="group-help">Select one or more to filter. If none are selected, this group is ignored.</div>
        <div class="tag-list" id="list-physical"></div>
      </details>
    </div>
    <div class="panel-actions">
      <button class="btn" id="clearFilters">Clear filters</button>
      <button class="btn btn-primary" id="applyFilters">Apply</button>
    </div>
  </aside>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    // ===== CONFIG =====
    const GEOJSON_URL = "https://api.tbc.city/disaster/org_points.geojson";

    // ===== MAP =====
    const map = L.map("map", { center: [37.8, -122.3], zoom: 9, scrollWheelZoom: true, tap: true });
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19, attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a>' }).addTo(map);
    const markersLayer = L.layerGroup().addTo(map);
    let allFeatures = [];
    let FIELDS = {}; // resolved at runtime

    // ===== UTILITIES =====
    const el = (s) => document.querySelector(s);

    // Normalize to array of strings
    function normalizeTags(value) {
      if (!value && value !== 0) return [];
      if (Array.isArray(value)) return value.map(v => String(v).trim()).filter(Boolean);
      return String(value).split(/[,;|]/).map(s => s.trim()).filter(Boolean);
    }

    // Robust key resolver: case/space/punct-insensitive
    function makeKey(s) {
      return String(s || "").toLowerCase().replace(/[\s._-]+/g, "").replace(/[^\p{L}\p{N}]/gu, "");
    }
    function resolveFieldsFromSample(sampleProps) {
      const keys = Object.keys(sampleProps || {});
      const byNorm = new Map(keys.map(k => [makeKey(k), k]));

      function pick(...candidates) {
        for (const c of candidates) {
          const norm = makeKey(c);
          if (byNorm.has(norm)) return byNorm.get(norm);
        }
        // fuzzy: look for substring match (e.g., "regularservices" inside "regularservices(tags)")
        for (const [nk, orig] of byNorm.entries()) {
          if (candidates.some(c => nk.includes(makeKey(c)))) return orig;
        }
        return null;
      }

      const resolved = {
        name:      pick("Organization Name","Org Name","Name"),
        website:   pick("Website","URL","Link"),
        type:      pick("Organization Type","Type","Category"),
        address:   pick("Full Address","Address"),
        contact:   pick("Disaster Contact","Contact","DisasterContact"),
        email:     pick("Disaster Email","Email","E-mail"),
        phone:     pick("Disaster Phone","Phone","Telephone"),
        regular:   pick("Regular Services","RegularServices"),
        disaster:  pick("Disaster Services","DisasterServices"),
        physical:  pick("Physical Resources","PhysicalResources","Resources"),
      };

      console.log("Detected field mapping:", resolved);
      return resolved;
    }

    function uniqueSortedTags(features, fieldKey) {
      const set = new Set();
      for (const f of features) normalizeTags(f.properties?.[fieldKey]).forEach(t => set.add(t));
      return Array.from(set).sort((a,b) => a.localeCompare(b));
    }

    function buildTagList(container, tags, groupKey) {
      container.innerHTML = "";
      for (const tag of tags) {
        const id = `${groupKey}-${tag.replace(/\s+/g, "_")}`;
        const label = document.createElement("label"); label.className = "tag-pill"; label.setAttribute("for", id);
        const input = document.createElement("input"); input.type = "checkbox"; input.id = id; input.value = tag; input.dataset.group = groupKey;
        const span = document.createElement("span"); span.textContent = tag;
        label.appendChild(input); label.appendChild(span); container.appendChild(label);
      }
    }

    function getSelected(groupKey) {
      return Array.from(document.querySelectorAll(`input[type="checkbox"][data-group="${groupKey}"]:checked`)).map(i => i.value);
    }

    function featureMatchesSelections(f, sel) {
      const p = f.properties || {};
      const reg = normalizeTags(p[FIELDS.regular]);
      const dis = normalizeTags(p[FIELDS.disaster]);
      const phy = normalizeTags(p[FIELDS.physical]);
      if (sel.regular.length && !sel.regular.some(t => reg.includes(t))) return false;
      if (sel.disaster.length && !sel.disaster.some(t => dis.includes(t))) return false;
      if (sel.physical.length && !sel.physical.some(t => phy.includes(t))) return false;
      return true;
    }

    // Color by Organization Type (stable hash → HSL)
    function hashCode(str) {
      let h = 0; for (let i=0;i<str.length;i++) { h = (h<<5) - h + str.charCodeAt(i); h |= 0; }
      return h >>> 0;
    }
    function colorForType(t) {
      const key = String(t || "Other");
      const h = hashCode(key) % 360;
      const s = 65, l = 50;
      return `hsl(${h} ${s}% ${l}%)`;
    }

    function makePopup(props) {
      const name = props[FIELDS.name] || "(No name)";
      const website = props[FIELDS.website];
      const orgType = props[FIELDS.type];
      const address = props[FIELDS.address];
      const contact = props[FIELDS.contact];
      const email = props[FIELDS.email];
      const phone = props[FIELDS.phone];
      const reg = normalizeTags(props[FIELDS.regular]);
      const dis = normalizeTags(props[FIELDS.disaster]);
      const phy = normalizeTags(props[FIELDS.physical]);
      const chips = arr => arr.map(t => `<span class="chip">${t}</span>`).join(" ");

      return `
        <div class="popup">
          <h3>${name}</h3>
          ${website ? `<div class="field-row"><b>Website:</b> <a href="${website}" target="_blank" rel="noopener">${website}</a></div>` : ""}
          ${orgType ? `<div class="field-row"><b>Type:</b> ${orgType}</div>` : ""}
          ${address ? `<div class="field-row"><b>Address:</b> ${address}</div>` : ""}
          ${contact ? `<div class="field-row"><b>Disaster Contact:</b> ${contact}</div>` : ""}
          ${email ? `<div class="field-row"><b>Email:</b> <a href="mailto:${email}">${email}</a></div>` : ""}
          ${phone ? `<div class="field-row"><b>Phone:</b> <a href="tel:${phone}">${phone}</a></div>` : ""}
          ${reg.length ? `<div class="field-row"><b>Regular Services:</b><div class="tag-strip">${chips(reg)}</div></div>` : ""}
          ${dis.length ? `<div class="field-row"><b>Disaster Services:</b><div class="tag-strip">${chips(dis)}</div></div>` : ""}
          ${phy.length ? `<div class="field-row"><b>Physical Resources:</b><div class="tag-strip">${chips(phy)}</div></div>` : ""}
        </div>`;
    }

    function clearMarkers() { markersLayer.clearLayers(); }

    function drawMarkers(features) {
      clearMarkers();
      const pts = [];

      features.forEach(f => {
        const [lng, lat] = f.geometry?.coordinates || [];
        if (typeof lat !== "number" || typeof lng !== "number") return;

        const props = f.properties || {};
        const t = props[FIELDS.type];
        const color = colorForType(t);

        const marker = L.circleMarker([lat, lng], {
          radius: 6, weight: 2, color: color, fillColor: color, opacity: 1, fillOpacity: 0.8
        });
        marker.bindPopup(makePopup(props));
        markersLayer.addLayer(marker);
        pts.push([lat, lng]);
      });

      if (pts.length) map.fitBounds(L.latLngBounds(pts).pad(0.08));
    }

    function applyFilters() {
      const selections = {
        regular: getSelected("regular"),
        disaster: getSelected("disaster"),
        physical: getSelected("physical")
      };
      drawMarkers(allFeatures.filter(f => featureMatchesSelections(f, selections)));
    }

    function clearFilters() {
      document.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
      applyFilters();
    }

    // ===== FETCH & INIT =====
    fetch(GEOJSON_URL)
      .then(r => r.json())
      .then(data => {
        const features = Array.isArray(data?.features) ? data.features : [];
        allFeatures = features;

        if (!features.length) {
          console.warn("No features in GeoJSON.");
          return;
        }

        // Resolve field names from the first feature
        FIELDS = resolveFieldsFromSample(features[0]?.properties || {});

        // Build filters
        const regTags = uniqueSortedTags(features, FIELDS.regular);
        const disTags = uniqueSortedTags(features, FIELDS.disaster);
        const phyTags = uniqueSortedTags(features, FIELDS.physical);
        buildTagList(el("#list-regular"), regTags, "regular");
        buildTagList(el("#list-disaster"), disTags, "disaster");
        buildTagList(el("#list-physical"), phyTags, "physical");

        // Draw
        drawMarkers(allFeatures);
      })
      .catch(err => {
        console.error("Failed to load GeoJSON:", err);
        alert("Failed to load disaster org data.");
      });

    // Buttons
    el("#applyFilters").addEventListener("click", applyFilters);
    el("#clearFilters").addEventListener("click", clearFilters);

    // Keep legend scroll local
    const scrollBox = el("#panelScroll");
    ["wheel","mousewheel","DOMMouseScroll"].forEach(evt =>
      scrollBox.addEventListener(evt, (e) => e.stopPropagation(), { passive: true })
    );
    let touchStartY = 0;
    scrollBox.addEventListener("touchstart", (e) => {
      if (e.touches?.length === 1) touchStartY = e.touches[0].clientY;
    }, { passive: true });
    scrollBox.addEventListener("touchmove", (e) => {
      if (e.touches?.length !== 1) return;
      const dy = e.touches[0].clientY - touchStartY;
      const atTop = scrollBox.scrollTop === 0;
      const atBottom = Math.ceil(scrollBox.scrollTop + scrollBox.clientHeight) >= scrollBox.scrollHeight;
      if ((atTop && dy > 0) || (atBottom && dy < 0)) e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
    el("#filterPanel").addEventListener("pointerdown", (e) => e.stopPropagation());
  </script>
</body>
</html>
