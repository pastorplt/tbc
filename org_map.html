<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>TBC Organizations Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/assets/favicon.ico" type="image/x-icon" />
  <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: calc(100% - 60px); }

    /* ===== Header / Nav (unchanged) ===== */
    header { background-color: #bf3426; color: #fff; }
    .nav { height: 60px; display: flex; align-items: center; gap: 16px; padding: 0 16px; max-width: 1100px; margin: 0 auto; }
    .nav .brand { display: flex; align-items: center; gap: 10px; text-decoration: none; color: #fff; font-weight: 800; letter-spacing: .3px; }
    .nav .brand img { height: 36px; width: auto; display: block; }
    .nav-links { display: flex; align-items: center; gap: 18px; margin-left: auto; }
    .nav-links a { color: #fff; text-decoration: none; font-weight: 700; padding: 6px 4px; border-radius: 4px; opacity: .9; }
    .nav-links a:hover { text-decoration: underline; opacity: 1; }
    .nav-links a.active { text-decoration: underline; opacity: 1; }
    .nav, .nav a, .nav .brand { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif !important; }

    /* Title chip */
    .map-title {
      position: absolute; top: 70px; left: 50%; transform: translateX(-50%);
      z-index: 1000;
      font: 40px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 800; color: #111; text-align: center;
      background: rgba(255,255,255,0.9);
      padding: 14px 25px; border-radius: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      pointer-events: none;
    }

    .leaflet-interactive { cursor: pointer; }

    /* ===== Legend / Filters ===== */
    .legend-panel {
      position: absolute; top: 70px; left: 10px;
      width: 300px; max-height: calc(100% - 90px);
      overflow-y: auto; z-index: 1000;
      background: rgba(255,255,255,0.95);
      border: 1px solid #e5e7eb; border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,.12);
      padding: 10px;
      font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y;
    }
    .legend-panel.closed { display: none; }
    .legend-header { display: none; }
    .legend-title { font-weight: 700; font-size: 14px; margin: 4px 0 8px; color: #111; }

    .dataset-selector {
      margin-bottom: 12px;
      padding: 10px;
      border: 1px solid #e5e7eb;
      border-radius: 10px;
      background: #f8fafc;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .dataset-title { font-weight: 700; font-size: 13px; color: #0f172a; text-transform: uppercase; letter-spacing: .04em; }
    .dataset-options { display: flex; flex-direction: column; gap: 8px; }
    .dataset-option { display: flex; align-items: flex-start; gap: 8px; font-size: 13px; cursor: pointer; }
    .dataset-option input { margin-top: 3px; cursor: pointer; }
    .dataset-info { display: flex; flex-direction: column; gap: 2px; }
    .dataset-name { font-weight: 600; color: #0f172a; }
    .dataset-meta { font-size: 11px; color: #475569; }
    .dataset-status { font-size: 12px; color: #475569; }

    details { margin-bottom: 8px; border-radius: 8px; background: #f8fafc; border: 1px solid #e5e7eb; padding: 6px 8px; }
    details[open] { background: #eef2ff; }
    summary { list-style: none; cursor: pointer; display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px 4px; font-weight: 600; }
    summary::-webkit-details-marker { display: none; }
    .chev { transition: transform .2s ease; }
    details[open] .chev { transform: rotate(90deg); }

    .tag-list { display: grid; grid-template-columns: 1fr; gap: 6px; margin-top: 8px; }
    .tag-pill { display: inline-flex; align-items: center; gap: 8px; border: 1px solid #e3e6ef; border-radius: 999px; padding: 6px 10px; background: #fff; font-size: 13px; user-select: none; cursor: pointer; }
    .tag-pill input { cursor: pointer; }

    .panel-actions { display: flex; gap: 8px; padding-top: 8px; margin-top: 8px; border-top: 1px solid #e5e7eb; }
    .btn { border: 1px solid #d9deea; background: #fff; padding: 8px 12px; border-radius: 10px; font-size: 13px; cursor: pointer; }
    .btn-primary { border-color: #3b82f6; background: #3b82f6; color: #fff; }

    /* ===== Popup content & chips ===== */
    .popup { font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; min-width: 240px; max-width: 360px; color: #111; }
    .popup h3 { font-size: 15px; margin: 0 0 6px; font-weight: 700; }
    .field-row { margin: 4px 0; overflow-wrap: break-word; }
    .field-row b { font-weight: 600; }
    .tag-strip { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .chip { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid transparent; font-size: 12px; line-height: 1.1; }
    .chip-colored { color: #fff; }
    .tag-pill.colored { border-color: transparent; }
    
    .prayer-request { margin-top: 8px; padding-top: 8px; border-top: 1px solid #e9ecef; }
    .prayer-request .label { font-weight: 700; display: block; margin-bottom: 2px; color: #bf3426; }

    .popup hr { border:0; border-top:1px solid #e9ecef; margin:8px 0; }

    /* Org Logo in Popup */
    .org-logo-wrap {
      text-align: center; margin-bottom: 12px; border-bottom: 1px solid #e9ecef; padding-bottom: 12px;
    }
    .org-logo {
      max-width: 140px; max-height: 80px; object-fit: contain; display: block; margin: 0 auto;
    }

    /* Show toggle on ALL viewports */
    .legend-toggle {
      display: inline-flex; align-items: center; justify-content: center;
      position: fixed; left: 12px; bottom: 12px; z-index: 1001;
      background: #111; color: #fff; border: 0;
      border-radius: 999px; padding: 10px 14px; font: 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.2);
    }
    .legend-toggle:active { transform: translateY(1px); }

    /* ===== Mobile-only bottom sheet (from networks map) ===== */
    .sheet{ position: fixed; inset:0; z-index:1002; display:none; }
    .sheet.open{ display:block; }
    .sheet-backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.35); }
    .sheet-panel{ position:absolute; left:0; right:0; bottom:0; background:#fff; border-radius:16px 16px 0 0; box-shadow: 0 -6px 24px rgba(0,0,0,.25); max-height:85vh; overflow:auto; padding:16px; }
    .sheet-close{ position:absolute; top:8px; right:8px; border:0; background:#f3f4f6; border-radius:999px; width:32px; height:32px; font-size:18px; }
    .sheet .tip{ font-size:14px; }
    .sheet .tip-name{ font-size:18px; margin-bottom:4px; }
    .sheet .actions{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .sheet .actions a{ color:#0a58ca; text-decoration:underline; font-weight:700; }
    @media (min-width: 768px){ .sheet{ display:none !important; } } /* only show on mobile */

    /* Mobile */
    @media (max-width: 767.98px) {
      .map-title { font-size: 22px; padding: 10px 16px; border-radius: 14px; }
      .legend-panel {
        position: fixed; top: 0; bottom: 0; left: 0; right: auto;
        width: 50vw; max-width: none; height: 100vh;
        border-radius: 0 12px 12px 0; padding: 8px 10px 12px;
        transform: translateX(-100%); transition: transform 220ms ease;
        border-left: 0; border-right: 1px solid #e5e7eb;
        box-shadow: 0 4px 16px rgba(0,0,0,.12);
        background: rgba(255,255,255,0.98);
        -webkit-overflow-scrolling: touch; overscroll-behavior: contain; touch-action: pan-y;
      }
      .legend-panel.open { transform: translateX(0); }

      .legend-header {
        display: flex; align-items: center; justify-content: space-between;
        gap: 8px; padding: 6px 2px 8px; position: sticky; top: 0;
        background: rgba(255,255,255,0.98); z-index: 2;
      }
      .legend-grabber { width: 40px; height: 4px; border-radius: 2px; background: #cbd5e1; margin: 4px auto 8px auto; }
      .legend-title { margin: 0 0 8px; }
      .legend-close-btn { border: none; background: #f3f4f6; color: #111; border-radius: 8px; padding: 6px 10px; font-size: 12px; cursor: pointer; }
      .legend-close-btn:active { transform: translateY(1px); }

      .desktop-only { display: none; }
      .leaflet-control-zoom { display: none !important; }
    }

    .leaflet-control-layers .basemap-heading,
    .leaflet-control-layers .overlays-heading { font-weight: 600; margin-bottom: 4px; display: block; }

    /* Make popup links clickable (no event swallowing) */
    .leaflet-popup-content a, .leaflet-popup-content button{ pointer-events:auto; }
  </style>
</head>
<body>
  <div id="navbar-include"></div>
  <script src="include-nav.js"></script>

  <div id="map">
    <div class="map-title">TBC Organizations</div>

    <button id="legendToggle" class="legend-toggle" type="button" aria-expanded="false" aria-controls="legendPanel">
      Filters
    </button>

    <aside class="legend-panel" id="legendPanel" aria-label="Filters">
      <div class="legend-header">
        <div class="legend-grabber" aria-hidden="true"></div>
        <div class="legend-title">Filters</div>
        <button class="legend-close-btn" type="button" id="legendClose">Close</button>
      </div>
      <div class="legend-title desktop-only">Filters</div>

      <div class="dataset-selector" id="datasetSelector" hidden>
        <div class="dataset-title">Organization data</div>
        <div id="datasetOptions" class="dataset-options"></div>
        <div id="datasetStatus" class="dataset-status"></div>
      </div>

      <details id="grp-county"><summary><span>County</span><span class="chev">▶</span></summary><div class="tag-list" id="list-county"></div></details>
      <details id="grp-network"><summary><span>Network Name</span><span class="chev">▶</span></summary><div class="tag-list" id="list-network"></div></details>
      <details id="grp-type"><summary><span>Organization Type</span><span class="chev">▶</span></summary><div class="tag-list" id="list-type"></div></details>
      <details id="grp-category"><summary><span>Category</span><span class="chev">▶</span></summary><div class="tag-list" id="list-category"></div></details>
      <details id="grp-denomination"><summary><span>Denomination</span><span class="chev">▶</span></summary><div class="tag-list" id="list-denomination"></div></details>

      <div class="panel-actions">
        <button class="btn" id="clearFilters">Clear filters</button>
        <button class="btn btn-primary" id="applyFilters">Apply</button>
      </div>
    </aside>
  </div>

  <div id="infoSheet" class="sheet" aria-hidden="true">
    <div class="sheet-backdrop" data-close="1"></div>
    <div class="sheet-panel" role="dialog" aria-modal="true" aria-labelledby="sheetTitle">
      <button class="sheet-close" type="button" data-close="1" aria-label="Close">×</button>
      <div id="sheetContent"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script>
    // ===== Basemaps =====
    const esriGray = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' });
    const cartoPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 20, subdomains: 'abcd', attribution: '&copy; OpenStreetMap contributors &copy; CARTO' });
    const esriWorldStreet = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' });
    const esriTopo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', { maxZoom: 20, attribution: 'Tiles &copy; Esri' });

    const map = L.map('map', {
      center: [37.8, -122.3], zoom: 9, layers: [esriGray], preferCanvas: true, zoomControl: false
    });
    L.control.zoom({ position: 'bottomright' }).addTo(map);

    const baseMaps = { 'Light': esriGray, 'Medium': cartoPositron, 'Street': esriWorldStreet, 'Topo': esriTopo };
    const layerControl = L.control.layers(baseMaps, null, { position: 'topright', collapsed: false }).addTo(map);
    const controlEl = layerControl.getContainer();
    const baseList = controlEl.querySelector('.leaflet-control-layers-base');
    if (baseList) { const h = document.createElement('div'); h.className = 'basemap-heading'; h.textContent = 'Basemap'; baseList.prepend(h); }

    const API_BASE = "https://api.tbc.city";
    const DEFAULT_GEOJSON_KEY = "organization_map.geojson";

    const datasetSelectorEl = document.getElementById('datasetSelector');
    const datasetOptionsEl = document.getElementById('datasetOptions');
    const datasetStatusEl = document.getElementById('datasetStatus');

    let allFeatures = [];
    let featureMap = new Map(); 
    let markersMap = new Map(); 
    let FIELDS = {};
    let preselectApplied = false;
    let initialParamsHandled = false;

    const datasetCache = new Map();
    let selectedDatasetKeys = new Set([DEFAULT_GEOJSON_KEY]);
    const el = (s) => document.querySelector(s);
    const $ = (s) => document.querySelectorAll(s);

    const normKey = (s) => String(s||'').toLowerCase().replace(/[\s._-]+/g,'').replace(/[^\p{L}\p{N}]/gu,'');
    function resolveFieldsFromSample(props) {
      const keys = Object.keys(props||{});
      const byNorm = new Map(keys.map(k => [normKey(k), k]));
      const pick = (...c) => { for (const cand of c) { const k = normKey(cand); if (byNorm.has(k)) return byNorm.get(k); } for (const [nk, orig] of byNorm.entries()) if (c.some(cand => nk.includes(normKey(cand)))) return orig; return null; };
      return {
        id: "id",
        name: pick("Organization Name","Org Name","Name","organization_name"),
        website: pick("Website","URL","Link","website"),
        category: pick("Category","Categories","category"),
        denomination: pick("Denomination","Denominations","denomination"),
        type: pick("Organization Type","Type","organization_type"),
        address: pick("Full Address","Address","full_address"),
        county: pick("County","county"),
        network: pick("Network Name","Network","network_name"),
        prayer: pick("Latest Prayer Request", "prayer_request", "prayer"),
        logo: pick("logo", "logo_url", "Org Logo")
      };
    }

    function normalizeTags(v) { if (!v && v !== 0) return []; if (Array.isArray(v)) return v.map(x => String(x).trim()).filter(Boolean); return String(v).split(/[,;|]/).map(s => s.trim()).filter(Boolean); }
    function uniqueSortedTags(features, fieldKey) { const set = new Set(); for (const f of features) normalizeTags(f.properties?.[fieldKey]).forEach(t => set.add(t)); return Array.from(set).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'})); }

    /* ===== Color logic ===== */
    const palette30 = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf','#393b79','#637939','#8c6d31','#843c39','#7b4173','#3182bd','#31a354','#756bb1','#636363','#e6550d','#9edae5','#c7c7c7','#bc80bd','#ffed6f','#a6cee3','#b2df8a','#fb9a99','#fdbf6f','#cab2d6','#6a3d9a'];
    function hashIndex(str, m){ let h=0; for(let i=0;i<str.length;i++) h=(h*31 + str.charCodeAt(i))|0; return Math.abs(h)%m; }
    function colorForFeature(props) { const key = `${props[FIELDS.name]||''}|${props[FIELDS.address]||''}`; return palette30[ hashIndex(key, palette30.length) ]; }

    const GLOBAL_TAG_COLORS = new Map();
    const GROUP_ORDER = ['type','county','network','category','denomination'];

    function canonicalizeTag(groupKey, tag){
      let t = String(tag||'').trim();
      if (!t) return '';
      if (groupKey === 'county') t = t.replace(/\s*county$/i, '');
      return t.toLowerCase();
    }

    function computeGlobalTagColors(features){
      GLOBAL_TAG_COLORS.clear();
      const perGroup = {};
      GROUP_ORDER.forEach(g => {
        const fk = FIELDS[g];
        const raw = fk ? uniqueSortedTags(features, fk) : [];
        const uniq = Array.from(new Set(raw.map(t => canonicalizeTag(g, t)).filter(Boolean)));
        perGroup[g] = uniq;
      });
      const idxByGroup = Object.fromEntries(GROUP_ORDER.map(g => [g, 0]));
      let assigned = 0;
      let remaining = GROUP_ORDER.reduce((acc,g) => acc + perGroup[g].length, 0);
      while (remaining > 0){
        for (const g of GROUP_ORDER){
          const arr = perGroup[g];
          const i = idxByGroup[g];
          if (i < arr.length){
            const canon = arr[i];
            const key = `${g}\u241F${canon}`;
            if (!GLOBAL_TAG_COLORS.has(key)){
              GLOBAL_TAG_COLORS.set(key, palette30[assigned % palette30.length]);
              assigned++;
              remaining--;
            }
            idxByGroup[g] = i + 1;
          }
        }
      }
    }

    function colorForTag(groupKey, tag){
      const canon = canonicalizeTag(groupKey, tag);
      const key = `${groupKey}\u241F${canon}`;
      if (GLOBAL_TAG_COLORS.has(key)) return GLOBAL_TAG_COLORS.get(key);
      return palette30[ hashIndex(key, palette30.length) ];
    }

    function contrastText(hex){ try { const h = hex.replace('#',''); const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16); const yiq=(r*299+g*587+b*114)/1000; return yiq>=150?'#111':'#fff'; } catch { return '#fff'; } }

    function datasetDisplayName(key) {
      if (!key || typeof key !== "string") return "GeoJSON";
      const normalizedKey = key.trim().toLowerCase();
      if (normalizedKey === DEFAULT_GEOJSON_KEY.toLowerCase()) return "TBC Data";
      const base = key.replace(/\.geojson$/i, "").replace(/[_-]+/g, " ").trim();
      return base ? base.replace(/\b\w/g, c=>c.toUpperCase()) : key;
    }

    function formatFileSize(bytes) {
      const n = Number(bytes);
      if (!Number.isFinite(n) || n <= 0) return "";
      if (n >= 1024 * 1024) return `${(n / (1024 * 1024)).toFixed(1)} MB`;
      if (n >= 1024) return `${Math.round(n / 1024)} KB`;
      return `${n} B`;
    }

    function formatDatasetMeta(file = {}) {
      const parts = [];
      if (file.key) parts.push(file.key);
      if (file.uploaded) {
        const dt = new Date(file.uploaded);
        if (!Number.isNaN(dt.getTime())) parts.push(`Updated ${dt.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' })}`);
      }
      if (file.size != null) {
        const size = formatFileSize(file.size);
        if (size) parts.push(size);
      }
      return parts.join(' • ');
    }

    function datasetUrlForKey(key) {
      if (typeof key !== "string" || !key.trim()) return `${API_BASE}/orgs/${DEFAULT_GEOJSON_KEY}`;
      return `${API_BASE}/orgs/${key.split('/').map(encodeURIComponent).join('/')}`;
    }

    async function loadDatasetList() {
      const resp = await fetch(`${API_BASE}/orgs`, { cache: 'no-cache' });
      if (!resp.ok) throw new Error(`Failed to list GeoJSON files (${resp.status})`);
      const data = await resp.json();
      const files = Array.isArray(data?.files) ? data.files : [];
      return files.filter(f => f && typeof f.key === 'string' && f.key.endsWith('.geojson'));
    }

    function loadDataset(key) {
      if (!datasetCache.has(key)) {
        const promise = (async () => {
          const resp = await fetch(datasetUrlForKey(key), { cache: 'no-cache' });
          if (!resp.ok) throw new Error(`Failed to load ${key} (${resp.status})`);
          const data = await resp.json();
          const features = Array.isArray(data?.features) ? data.features : [];
          return features.filter(f => f && f.type === 'Feature');
        })().catch(err => {
          datasetCache.delete(key);
          throw err;
        });
        datasetCache.set(key, promise);
      }
      return datasetCache.get(key);
    }

    function churchSVG(color, size=20){
      const s = Number(size) || 20;
      return `\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="${s}" height="${s}" aria-hidden="true">\n  <path d="M7 10 L12 4 L17 10 L17 18 L7 18 Z" fill="${color}"/>\n</svg>`;
    }
    function makeChurchIcon(color){
      const html = churchSVG(color, 20);
      return L.divIcon({ html, className: 'church-marker', iconSize: [20, 20], iconAnchor: [10, 18], popupAnchor: [0, -18] });
    }

    function buildTagList(container, tags, groupKey) {
      container.innerHTML = "";
      tags.forEach(tag => {
        const id = `${groupKey}-${tag.replace(/\s+/g,"_")}`;
        const label = document.createElement('label');
        label.className = 'tag-pill colored';
        label.setAttribute('for', id);
        const bg = colorForTag(groupKey, tag);
        const fg = contrastText(bg);
        label.style.background = bg; label.style.color = fg; label.style.borderColor = 'transparent';

        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = id; input.value = tag; input.dataset.group = groupKey;

        const span = document.createElement('span'); span.textContent = tag;
        label.appendChild(input); label.appendChild(span); container.appendChild(label);
      });
    }

    function buildDatasetSelector(files = []) {
      if (!datasetOptionsEl) return;
      const dedup = new Map();
      files.forEach(file => {
        if (!file || typeof file.key !== 'string' || !file.key.endsWith('.geojson')) return;
        if (!dedup.has(file.key)) dedup.set(file.key, file);
      });
      if (!dedup.has(DEFAULT_GEOJSON_KEY)) dedup.set(DEFAULT_GEOJSON_KEY, { key: DEFAULT_GEOJSON_KEY });

      const sorted = Array.from(dedup.values()).sort((a, b) => {
        const timeA = Date.parse(a?.uploaded || ''), timeB = Date.parse(b?.uploaded || '');
        if (!Number.isNaN(timeA) && !Number.isNaN(timeB) && timeA !== timeB) return timeB - timeA;
        return String(a.key).localeCompare(String(b.key));
      });

      const availableKeys = new Set(sorted.map(f => f.key));
      selectedDatasetKeys = new Set(Array.from(selectedDatasetKeys).filter(key => availableKeys.has(key)));
      if (selectedDatasetKeys.size === 0) selectedDatasetKeys.add(DEFAULT_GEOJSON_KEY);

      datasetOptionsEl.innerHTML = '';
      sorted.forEach(file => {
        const option = document.createElement('label');
        option.className = 'dataset-option';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.value = file.key;
        input.checked = selectedDatasetKeys.has(file.key);
        const info = document.createElement('div');
        info.className = 'dataset-info';
        const nameSpan = document.createElement('div');
        nameSpan.className = 'dataset-name';
        nameSpan.textContent = datasetDisplayName(file.key);
        info.appendChild(nameSpan);
        const metaText = formatDatasetMeta(file);
        if (metaText) {
          const metaSpan = document.createElement('div');
          metaSpan.className = 'dataset-meta';
          metaSpan.textContent = metaText;
          info.appendChild(metaSpan);
        }
        option.appendChild(input); option.appendChild(info);
        input.addEventListener('change', async () => {
          const checked = input.checked;
          if (checked) selectedDatasetKeys.add(file.key); else selectedDatasetKeys.delete(file.key);
          if (datasetStatusEl) datasetStatusEl.textContent = 'Loading…';
          try {
            const result = await refreshDatasets({ preserveFilters: true });
            updateDatasetStatus(result);
          } catch (err) {
            console.error('Failed to load datasets', err);
            if (datasetStatusEl) datasetStatusEl.textContent = 'Failed to load data.';
            input.checked = !checked;
            if (checked) selectedDatasetKeys.delete(file.key); else selectedDatasetKeys.add(file.key);
            updateDatasetStatus({ datasetCount: selectedDatasetKeys.size, featureCount: allFeatures.length });
          }
        });
        datasetOptionsEl.appendChild(option);
      });
    }

    function updateDatasetStatus(info = {}) {
      if (!datasetStatusEl) return;
      const datasetCount = Number(info.datasetCount || info.datasets || 0);
      const featureCount = Number(info.featureCount || info.features || 0);
      if (!datasetCount) { datasetStatusEl.textContent = 'Select at least one dataset to display.'; return; }
      datasetStatusEl.textContent = `Showing ${datasetCount} ${datasetCount===1?'dataset':'datasets'} (${featureCount} ${featureCount===1?'location':'locations'})`;
    }

    function chipsRow(props){
      const typeVals = normalizeTags(props[FIELDS.type]);
      const countyValsRaw = normalizeTags(props[FIELDS.county]);
      const networkVals = normalizeTags(props[FIELDS.network]);
      const categoryVals = normalizeTags(props[FIELDS.category]);
      const denomVals = normalizeTags(props[FIELDS.denomination]);
      const makeChip = (groupKey, text, displayText) => {
        const bg = colorForTag(groupKey, text);
        const fg = contrastText(bg);
        return `<span class="chip chip-colored" style="background:${bg};color:${fg};">${displayText ?? text}</span>`;
      };
      const chips = [
        ...typeVals.map(t => makeChip('type', t)),
        ...countyValsRaw.map(t => makeChip('county', t, /county\b/i.test(t) ? t : `${t} County`)),
        ...networkVals.map(t => makeChip('network', t)),
        ...categoryVals.map(t => makeChip('category', t)),
        ...denomVals.map(t => makeChip('denomination', t)),
      ];
      if (!chips.length) return '';
      return `<div class="tag-strip">${chips.join('')}</div>`;
    }

    // UPDATED: Show Logo if present
    function infoHtml(props) {
      const name = props[FIELDS.name] || "(No name)";
      const website = props[FIELDS.website];
      const address = props[FIELDS.address];
      const prayerRequest = props[FIELDS.prayer];
      const logoUrl = props[FIELDS.logo];

      let prayerHtml = '';
      if (prayerRequest && String(prayerRequest).trim()) {
        prayerHtml = `<div class="prayer-request">
          <span class="label">Prayer Request:</span>
          <div>${String(prayerRequest).trim()}</div>
        </div>`;
      }

      let logoHtml = '';
      if (logoUrl) {
        logoHtml = `<div class="org-logo-wrap">
          <img src="${logoUrl}" alt="${name} logo" class="org-logo" loading="lazy">
        </div>`;
      }

      return `<div class="popup">
        ${logoHtml}
        <h3>${name}</h3>
        ${address ? `<div class="field-row"><b>Address:</b> ${address}</div>` : ""}
        ${website ? `<div class="field-row"><b>Website:</b> <a href="${website}" target="_blank" rel="noopener">${website}</a></div>` : ""}
        ${chipsRow(props)}
        ${prayerHtml}
      </div>`;
    }

    const markersLayer = L.layerGroup().addTo(map);
    function clearMarkers(){ markersLayer.clearLayers(); markersMap.clear(); }

    // ===== Bottom sheet helpers =====
    const sheetEl = document.getElementById('infoSheet');
    const sheetContentEl = document.getElementById('sheetContent');
    let scrollLockY = 0;
    function lockScroll() { scrollLockY = window.scrollY || document.documentElement.scrollTop || 0; document.body.style.position='fixed'; document.body.style.top=`-${scrollLockY}px`; document.body.style.left='0'; document.body.style.right='0'; document.body.style.width='100%'; document.body.style.overflow='hidden'; document.documentElement.style.overflow='hidden'; }
    function unlockScroll() { document.body.style.position=''; document.body.style.top=''; document.body.style.left=''; document.body.style.right=''; document.body.style.width=''; document.body.style.overflow=''; document.documentElement.style.overflow=''; window.scrollTo(0, scrollLockY); }
    function isMobile() { return window.matchMedia('(max-width: 767.98px)').matches; }
    function openSheet(html){ if (!sheetEl) return; sheetContentEl.innerHTML = html; sheetEl.classList.add('open'); sheetEl.setAttribute('aria-hidden','false'); lockScroll(); }
    function closeSheet(){ if (!sheetEl) return; sheetEl.classList.remove('open'); sheetEl.setAttribute('aria-hidden','true'); unlockScroll(); }
    if (sheetEl) { sheetEl.addEventListener('click', (e) => { const t = e.target; if (t.matches('[data-close]')) { e.stopPropagation(); closeSheet(); } }, { passive:false }); }

    function drawMarkers(features) {
      clearMarkers();
      const pts = [];
      features.forEach(f => {
        const [lng, lat] = f.geometry?.coordinates || [];
        if (typeof lat !== "number" || typeof lng !== "number") return;
        const props = f.properties || {};
        const color = colorForFeature(props);
        const icon = makeChurchIcon(color);
        const m = L.marker([lat, lng], { icon });

        const recId = props.id;
        if (recId) markersMap.set(recId, { marker: m, props });

        m.on('click', () => {
          const html = infoHtml(props);
          if (isMobile()) { openSheet(html); } else { m.bindPopup(html, { maxWidth: 420, closeOnClick: true, autoClose: true }).openPopup(); }
        });

        markersLayer.addLayer(m);
        pts.push([lat, lng]);
      });
      if (pts.length && !initialParamsHandled) map.fitBounds(L.latLngBounds(pts).pad(0.08));
    }

    function applyFilters() {
      const selections = getCurrentFilterSelections();
      drawMarkers(filterFeaturesBySelections(selections));
      collapseAllSections();
    }
    function clearFilters() {
      document.querySelectorAll('#legendPanel input[type="checkbox"][data-group]').forEach(cb => cb.checked = false);
      applyFilters();
    }
    function collapseAllSections() { document.querySelectorAll('#legendPanel details[open]').forEach(d => d.removeAttribute('open')); }

    function getSelected(groupKey) { return Array.from(document.querySelectorAll(`input[type="checkbox"][data-group="${groupKey}"]:checked`)).map(i => i.value); }
    function getCurrentFilterSelections() {
      return {
        county: getSelected("county"),
        network: getSelected("network"),
        type: getSelected("type"),
        category: getSelected("category"),
        denomination: getSelected("denomination"),
      };
    }
    function featureMatchesSelections(f, sel) {
      const p = f.properties || {};
      const county = normalizeTags(p[FIELDS.county]);
      const network = normalizeTags(p[FIELDS.network]);
      const type = normalizeTags(p[FIELDS.type]);
      const category = normalizeTags(p[FIELDS.category]);
      const denom = normalizeTags(p[FIELDS.denomination]);
      if (sel.county.length && !sel.county.some(t => county.includes(t))) return false;
      if (sel.network.length && !sel.network.some(t => network.includes(t))) return false;
      if (sel.type.length && !sel.type.some(t => type.includes(t))) return false;
      if (sel.category.length && !sel.category.some(t => category.includes(t))) return false;
      if (sel.denomination.length && !sel.denomination.some(t => denom.includes(t))) return false;
      return true;
    }
    function filterFeaturesBySelections(selections) { return allFeatures.filter(f => featureMatchesSelections(f, selections)); }
    function applyFilterSelectionsState(selections = {}) {
      Object.entries(selections).forEach(([group, values]) => {
        const desired = new Set((values || []).map(v => String(v).toLowerCase()));
        document.querySelectorAll(`input[type="checkbox"][data-group="${group}"]`).forEach(cb => {
          cb.checked = desired.has(cb.value.toLowerCase());
        });
      });
    }

    function handleInitialUrlParams() {
      if (initialParamsHandled || allFeatures.length === 0) return;
      initialParamsHandled = true;

      const params = new URLSearchParams(window.location.search);
      const targetId = params.get('id');
      const targetOrg = params.get('org');
      const randomMode = params.get('random');

      if (targetId && markersMap.has(targetId)) {
        const { marker, props } = markersMap.get(targetId);
        openAndZoom(marker, props);
        return;
      }

      if (targetOrg) {
        const targetName = targetOrg.toLowerCase().trim();
        const match = allFeatures.find(f => {
          const name = (f.properties[FIELDS.name] || "").toLowerCase();
          return name.includes(targetName);
        });
        if (match && match.properties.id && markersMap.has(match.properties.id)) {
          const { marker, props } = markersMap.get(match.properties.id);
          openAndZoom(marker, props);
          return;
        }
      }

      if (randomMode) {
        let candidates = allFeatures;
        
        if (randomMode === '2') {
          candidates = allFeatures.filter(f => {
            const req = f.properties[FIELDS.prayer];
            return req && String(req).trim().length > 0;
          });
          if (candidates.length === 0) return; 
        }

        if (candidates.length > 0) {
          const pick = candidates[Math.floor(Math.random() * candidates.length)];
          const recId = pick.properties.id;
          if (recId && markersMap.has(recId)) {
            const { marker, props } = markersMap.get(recId);
            setTimeout(() => openAndZoom(marker, props), 200);
          }
        }
      }
    }

    function openAndZoom(marker, props) {
      if (!marker) return;
      const latLng = marker.getLatLng();
      map.setView(latLng, 16, { animate: true });
      
      const html = infoHtml(props);
      if (isMobile()) {
        openSheet(html);
      } else {
        marker.bindPopup(html, { maxWidth: 420, closeOnClick: true, autoClose: true }).openPopup();
      }
    }

    function preselectFromParams() {
      const params = new URLSearchParams(location.search);
      const preCounty = (params.get('county')||'').split(',').map(s=>s.trim()).filter(Boolean);
      const preNetwork = (params.get('network')||'').split(',').map(s=>s.trim()).filter(Boolean);
      preCounty.forEach(v => { const cb = Array.from($('input[type="checkbox"][data-group="county"]')).find(i => i.value.toLowerCase() === v.toLowerCase()); if (cb) cb.checked = true; });
      preNetwork.forEach(v => { const cb = Array.from($('input[type="checkbox"][data-group="network"]')).find(i => i.value.toLowerCase() === v.toLowerCase()); if (cb) cb.checked = true; });
      if (preCounty.length || preNetwork.length) applyFilters();
    }

    function updateFeatureData(features = [], previousSelections) {
      allFeatures = Array.isArray(features) ? features : [];
      featureMap.clear();
      allFeatures.forEach(f => { if(f.properties?.id) featureMap.set(f.properties.id, f); });

      const sampleFeature = allFeatures.find(f => f && f.properties && Object.keys(f.properties || {}).length) || null;
      const sampleProps = sampleFeature ? sampleFeature.properties : {};
      FIELDS = resolveFieldsFromSample(sampleProps || {});
      computeGlobalTagColors(allFeatures);

      const countyList = el('#list-county');
      if (countyList) buildTagList(countyList, FIELDS.county ? uniqueSortedTags(allFeatures, FIELDS.county) : [], 'county');

      const networkList = el('#list-network');
      if (networkList) buildTagList(networkList, FIELDS.network ? uniqueSortedTags(allFeatures, FIELDS.network) : [], 'network');

      const typeList = el('#list-type');
      if (typeList) buildTagList(typeList, FIELDS.type ? uniqueSortedTags(allFeatures, FIELDS.type) : [], 'type');

      const categoryList = el('#list-category');
      const categoryGroup = el('#grp-category');
      const catTags = FIELDS.category ? uniqueSortedTags(allFeatures, FIELDS.category) : [];
      if (categoryList) {
        if (catTags.length) {
          buildTagList(categoryList, catTags, 'category');
          if (categoryGroup) categoryGroup.style.display = '';
        } else {
          categoryList.innerHTML = '';
          if (categoryGroup) categoryGroup.style.display = 'none';
        }
      }

      const denomList = el('#list-denomination');
      const denomGroup = el('#grp-denomination');
      const denomTags = FIELDS.denomination ? uniqueSortedTags(allFeatures, FIELDS.denomination) : [];
      if (denomList) {
        if (denomTags.length) {
          buildTagList(denomList, denomTags, 'denomination');
          if (denomGroup) denomGroup.style.display = '';
        } else {
          denomList.innerHTML = '';
          if (denomGroup) denomGroup.style.display = 'none';
        }
      }

      if (previousSelections) {
        applyFilterSelectionsState(previousSelections);
        drawMarkers(filterFeaturesBySelections(previousSelections));
      } else {
        drawMarkers(allFeatures);
        if (!preselectApplied) {
          preselectFromParams();
          preselectApplied = true;
        }
        handleInitialUrlParams();
      }
    }

    async function refreshDatasets({ preserveFilters = true } = {}) {
      const keys = Array.from(selectedDatasetKeys);
      const previousSelections = preserveFilters && preselectApplied ? getCurrentFilterSelections() : null;

      if (!keys.length) {
        updateFeatureData([], previousSelections);
        return { datasetCount: 0, featureCount: 0 };
      }

      const collections = await Promise.all(keys.map(loadDataset));
      const combined = collections.flat().filter(f => f && f.type === 'Feature');
      updateFeatureData(combined, previousSelections);
      return { datasetCount: keys.length, featureCount: combined.length };
    }

    async function loadDefaultDataset(silent = false) {
      selectedDatasetKeys = new Set([DEFAULT_GEOJSON_KEY]);
      if (datasetSelectorEl) datasetSelectorEl.hidden = true;
      if (datasetOptionsEl) datasetOptionsEl.innerHTML = '';
      if (datasetStatusEl) datasetStatusEl.textContent = '';
      try {
        const features = await loadDataset(DEFAULT_GEOJSON_KEY);
        updateFeatureData(features, null);
      } catch (err) {
        console.error('Failed to load org GeoJSON:', err);
        if (!silent) alert('Failed to load organization map data.');
      }
    }

    async function initializeDatasets() {
      try {
        if (datasetSelectorEl) datasetSelectorEl.hidden = false;

        let files = [];
        let listMessage = '';
        try {
          files = await loadDatasetList();
        } catch (err) {
          console.error('Failed to list GeoJSON files', err);
          listMessage = 'Failed to load dataset list. Showing default data.';
          if (datasetStatusEl) datasetStatusEl.textContent = listMessage;
        }

        buildDatasetSelector(files);

        try {
          const result = await refreshDatasets({ preserveFilters: false });
          updateDatasetStatus(result);
          if (listMessage && datasetStatusEl) {
            datasetStatusEl.textContent = `${listMessage} ${datasetStatusEl.textContent}`.trim();
          }
        } catch (err) {
          console.error('Failed to load datasets', err);
          if (datasetStatusEl) datasetStatusEl.textContent = 'Failed to load data.';
        }
      } catch (err) {
        console.error('Failed to initialize datasets', err);
        await loadDefaultDataset(true);
      }
    }

    initializeDatasets();

    el("#applyFilters").addEventListener("click", applyFilters);
    el("#clearFilters").addEventListener("click", clearFilters);

    const legendPanel = document.getElementById('legendPanel');
    const legendToggle = document.getElementById('legendToggle');
    const legendClose = document.getElementById('legendClose');

    L.DomEvent.disableScrollPropagation(legendPanel);
    L.DomEvent.disableClickPropagation(legendPanel);

    function openLegend() { if (isMobile()) { legendPanel.classList.add('open'); lockScroll(); } legendPanel.classList.remove('closed'); if (legendToggle) legendToggle.setAttribute('aria-expanded', 'true'); }
    function closeLegend() { if (isMobile()) { legendPanel.classList.remove('open'); unlockScroll(); } legendPanel.classList.add('closed'); if (legendToggle) legendToggle.setAttribute('aria-expanded', 'false'); }

    if (legendToggle) legendToggle.addEventListener('click', () => {
      const isHiddenDesktop = legendPanel.classList.contains('closed');
      const isOpenMobile = legendPanel.classList.contains('open');
      (isMobile() ? !isOpenMobile : isHiddenDesktop) ? openLegend() : closeLegend();
    });
    if (legendClose) legendClose.addEventListener('click', closeLegend);

    map.on('popupopen', (e) => {
      const el = e.popup && e.popup.getElement && e.popup.getElement();
      if (!el) return; try { L.DomEvent.disableClickPropagation(el); L.DomEvent.disableScrollPropagation(el); } catch {}
    });
  </script>
</body>
</html>
